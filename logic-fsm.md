# Developing the state machine

In chapter [Making the board interactive](./logic-events.md#defining-the-state-machine) we saw that the board basically behaves accordingly to a certain state machine. That state machine and the algorithm that described in that same chapter is what we are going to implement now. Let's go back to `board.js` and start writing `_onClickHandler`. When we left the development on that function, we were experimenting with events. Let's remove the `console.log` that we wrote and let's start from here:

```javascript
function _onClickHandler(e) {
    // The code will end up here...
}
```

## Defining the cancel procedure
The first thing we wanna do is defining an internal function (a function that only `_onClickHandler` can access to) which deals with cancelling the operation. As we saw in the algorithm diagram in chapter [Making the board interactive](./logic-events.md), we have many checkpoints, and if something goes wrong, instead of failing, we cancel the operation.

The way to define a function which is visible to only one other function is to have former defined insinde the latter, so let's do this:

```javascript
function _onClickHandler(e) {
    function cancel(phase) {
        // Code for the internal function here...
    }

    // Code for the click handler here...
}
```

Like this, `cancel` can only be called from inside `_onClickHandler`. We want to make sure that `cancel` can only be called by the click handler because this functionality is extremely specific to this context. Before digging into the details of the 2 functions, we need to explain the approach we are planning for canceling one operation.

### Understanding how to cancel an operation
Events are not easy to understand and can be complicated. However here we will try to describe them in a very easy way. The key concept is understanding that events travel across elements in the page.

If you recall, we have defined 2 event handlers for the `click` event:

- One in the `Board` module on the `container` element.
- One in the `House` module on every `house` element.

What happens when a user clicks on an house on the page? To understand this answer, we need to focus on the page subtree that starts from that element and walks all the parent elements up to the `<body>` element. In our case, we have the following subtree:

```html
<body>
    <div class="container">
        <div class="house"></div>
    </div>
</body>
```

When the user clicks on that house `<div class="house"></div>`, this is what happens:

1. A `click` event is generated by the browser and is sent to the `<body>` element.
2. Right after, the event is sent to the `<div class="container">` element.
3. In the end, the event reaches the `<div class="house">` element.

Everytime the event reaches one element, if there are listeners registered on that element for the `click` event, those will be executed. Since both `<div class="container">` and `<div class="house">` define one event handler for the `click` event, first the event handler for the container is executed and then the one for the house. This dynamics is called _event propagation_.

#### Changing the event flow
However, if anyone of the event handlers calls `stopPropagation`, then the event will stop and not proceed any further down.

The same event traverses the subtree until it reaches `<div class="house"></div>`. This last element is called _target element_ because is the element which was actually clicked by the user and that is the element where the event chain will stop.

Every intermediate element that the event traverses before reaching the target is called a _non-target element_.

An event handler on an element for a certain event is registered in this way:

```javascript
element.addEventListener("click", clickEventHandler);

function clickEventHandler(e) {
    // The handler code
}
```

The event handler is `clickEventHandler` (we have coded something similar so far) and you see it always accepts an argument called `e`. That argument is called `event arguments` because it will contain information about the event as it traverses the subtree. We are interested in 2 particular properties of this object:

- Property `e.target` contains a reference to the target element of the event.
- Property `e.currentTarget` contains a reference to the intermediate element that the event is currently traversing. When the event reaches the target, `e.currentTarget` and `e.target` will have the same value.

Object `e` is very important because it gives us a chance to understand where the event is currently at in the subtree. However remember that if some event handler calls `e.stopPropagation()`, then the event will not proceed any further. So, to understand this dynamics, let's make a simulation with this example by considering 2 cases.

##### Non stopping the propagation
When no handler stops the propagation of the event, we have the following scenario:

| # | Element                   | Handler? | `e.target`            | `e.currentTarget`         |
|:-:|:--------------------------|:--------:|:---------------------:|:-------------------------:|
| 1 | `<body>`                  | No       | `<div class="house">` | `<body>`                  |
| 2 | `<div class="container">` | Yes      | `<div class="house">` | `<div class="container">` |
| 3 | `<div class="house">`     | Yes      | `<div class="house">` | `<div class="house">`     |

Note that `body` cannot stop the propagation because there is no handler defined there.

##### Stopping the propagation
When `<div class="container">` stops the propagation of the event, we have the following scenario:

| # | Element                   | Handler? | `e.target`            | `e.currentTarget`         |
|:-:|:--------------------------|:--------:|:---------------------:|:-------------------------:|
| 1 | `<body>`                  | No       | `<div class="house">` | `<body>`                  |
| 2 | `<div class="container">` | Yes      | `<div class="house">` | `<div class="container">` |

Since `<div class="container">` stops the propagation, the event will not reach `<div class="house">`!

#### Event propagation and cancel strategy
Remember that we have set 2 different handlers for `click`: one on container and one on each house. When one player clicks on one house, the event will:

1. Start from `<body>`.
2. Propagate to `<div class="container">`, which will cause the event handler registered there to be executed.
3. Propagate to `<div class="house">`, which will trigger the other handler defined there.

Since `_onClickHandler` in the board does not call `e.stopPropagation()`, the event will reach the target (the house). The handler on the house will flip its `background-color` so that the house looks highlighted. Our cancel approach is very simple and consists in the following:

> When the player clicks on an house, the handler in the container will try to run the game interaction to move pieces. Typically this will result in that house to be highlighted. However, if something goes wrong, the operation will be canceled and the event stopped via `e.stopPropagation()` so that the house does not receive highlight.

It basically means the following:

```javascript
function _onClickHandler(e) {
    function cancel(phase) {
        e.stopPropagation();
        if (selectedHouse) {
            _clearSelectedHouse();
        }

        console.log("Interaction canceled at", phase);
    }

    // More code will go here...
}
```

You can see that, in `cancel`, we stop the propagation so that the house does not receive highlight, and we also clear the currently selected house. For example, if the player selectes one horse because he wants to move it, then that house will be highlighted; but if later the player selected another house which makes the horse move in an invalid way, then we need to remove the highlight from the initial house and the player will have to repeat the move. In our design, everytime the user enters the _Wait move complete_ state because he wants to move an horse, we save the initial house in `selectedHouse`. The purpose of `_clearSelectedHouse` is removing the highlight from the selected house and then resetting the value of `selectedHouse` (which means that we go back to state `Wait move`).

We can write down the code for `_clearSelectedHouse` right before `_onClickHandler`:

```javascript
function _clearSelectedHouse() {
    selectedHouse.clear();
    selectedHouse = null;
}
```

Back to `cancel`, please note that we use parameter `phase` to pass a string. We will use it for logging, so that if an error occurs, we know at which stage we have canceled the operation.

## Retrieving the clicked house
When the user clicks on one house we can be in 2 possible states:

- We can be in state `Wait move`, so it means that the player wants to start moving a piece by selecting the source house.
- We can be in state `Wait move complete`, so it means that the player is selecting the destination house.

In the first part of `_onClickHandler` we need to figure out which one of the 2 states we are in. The way to do that is checking `selectedHouse`. When the player selected the source house, we will always store it into that variable. So we can check if the variable has an house or not to understand which state we are into. However before doing that we will carry on some operations that are common to handling both states. These operations concern getting the house that the player has selected. So, back to `_onClickHandler`, let's add the following lines at the end of the function's body:

```javascript
var target = e.target;
if (!target) { cancel("House Acquire"); return; }
```

The evenr arguments `e` has property `e.target` which contains the target element. We will get a reference to the house from there. Of course we need to check that a target is present, otherwise we cancel the operation. The next code we need is the following:

```javascript
var id = target.id;
if (!id) {
    // Player might have selected a horse
    var parent = target.parentElement;
    if (!parent) { cancel("House Acquire"); return; }

    id = parent.id;
}
```

Remember that every house has an `id` set with the coordinates of that house. We made sure that we have this behavior when we developed function `_build` in chapter [Continuing on the board creation](./board-cont.md#finishing-up-the-board-building-function). However what if the mouse cursor hits the horse inside one house? In that case `e.target` will point to the horse element, not the house! In that case we would have no `id` defined, so we can check the parent (horses are contained by houses). After making this additional check, we should have the id, we can move on:

```javascript
// Could not find the house
if (!id) { cancel("House Acquire"); return; }
```

The code we just wrote is pretty straightforward: we still need to check that we have a valid id, otherwise we cancel. Now we are ready to retrieve the house basing on the id:

```javascript
var house = houses[id];
if (!house) {
    throw "Click handler failed. Cannot find house at " + id;
}
```

If an house cannot be found, we cannot cancel because we must find an house. If we don't find it then we need to fail! The next code branches in order to consider the 2 cases we mentioned before.

```javascript
if (!selectedHouse) {
    // Here is the code for when we are in state "Wait move"...
}

// From here, the code for when we are in state "Wait move complete"...
```

The code inside the `if` block will be executed when we are in state _Wait move_. Otherwise the code after the conditional block will be executed (state `Wait move complete`).

## Handling the _Wait move_ state
Let's focus on the code inside the last `if` we wrote. If we fall inside that path, then the player is selecting the source house for selecting which horse he wants to move. Recalling the algorithm diagram we drew in chapter [Making the board interactive](./logic-events.md#an-overview-of-the-moving-logic), we need to do implement the flow wihch follows the _Selection_ branch.
